import{_ as c,F as h,G as R,H as f,d as E,I as F,J as I,K as g}from"./convertFieldResponseIntoMuiTextFieldProps-1cae98ec.js";const u=n=>{const e=[],t=[];return n.forEach(r=>{r.dateName==="start"?e.push(r):t.push(r)}),{startDate:e,endDate:t}},T=n=>n.map((e,t)=>t===n.length-1?c({},e,{separator:null}):e),z=["value","referenceDate"],K={emptyValue:[null,null],getTodayValue:(n,e,t)=>[f(n,e,t),f(n,e,t)],getInitialReferenceValue:n=>{let{value:e,referenceDate:t}=n,r=E(n,z);const a=e[0]!=null&&r.utils.isValid(e[0]),l=e[1]!=null&&r.utils.isValid(e[1]);if(a&&l)return e;const s=t??F(r);return[a?e[0]:s,l?e[1]:s]},cleanValue:(n,e)=>e.map(t=>I(n,t)),areValuesEqual:(n,e,t)=>g(n,e[0],t[0])&&g(n,e[1],t[1]),isSameError:(n,e)=>e!==null&&n[1]===e[1]&&n[0]===e[0],hasError:n=>n[0]!=null||n[1]!=null,defaultErrorState:[null,null],getTimezone:(n,e)=>{const t=e[0]==null||!n.isValid(e[0])?null:n.getTimezone(e[0]),r=e[1]==null||!n.isValid(e[1])?null:n.getTimezone(e[1]);if(t!=null&&r!=null&&t!==r)throw new Error("MUI X: The timezone of the start and the end date should be the same.");return t??r},setTimezone:(n,e,t)=>[t[0]==null?null:n.setTimezone(t[0],e),t[1]==null?null:n.setTimezone(t[1],e)]},x=({dateSeparator:n="â€“"})=>({updateReferenceValue:(e,t,r)=>{const a=t[0]!=null&&e.isValid(t[0]),l=t[1]!=null&&e.isValid(t[1]);return!a&&!l?r:a&&l?t:a?[t[0],r[0]]:[r[1],t[1]]},getSectionsFromValue:(e,[t,r],a,l)=>{const s=a==null?{startDate:null,endDate:null}:u(a),o=(D,V,i)=>{if(!e.isValid(D)&&!!V)return V;const S=l(D);return S.map((d,p)=>p===S.length-1&&i==="start"?c({},d,{dateName:i,endSeparator:`${d.endSeparator} ${n} `}):c({},d,{dateName:i}))};return[...o(t,s.startDate,"start"),...o(r,s.endDate,"end")]},getV7HiddenInputValueFromSections:e=>{const t=u(e);return h([...t.startDate,...t.endDate])},getV6InputValueFromSections:(e,t,r)=>{const a=u(e);return R([...a.startDate,...a.endDate],t,r)},parseValueStr:(e,t,r)=>{const[a,l]=e.split(n);return[a,l].map((s,o)=>s==null?null:r(s.trim(),t[o]))},getActiveDateManager:(e,t,r)=>{const a=r.dateName==="start"?0:1,l=(s,o)=>a===0?[s,o[1]]:[o[0],s];return{date:t.value[a],referenceDate:t.referenceValue[a],getSections:s=>{const o=u(s);return a===0?T(o.startDate):o.endDate},getNewValuesFromNewActiveDate:s=>({value:l(s,t.value),referenceValue:s==null||!e.isValid(s)?t.referenceValue:l(s,t.referenceValue)})}}}),m=(n,e)=>!!(e&&e[0]&&e[1]&&!n.isBefore(e[1],e[0])),M=(n,e,t)=>m(n,t)&&n.isWithinRange(e,t),P=(n,e,t)=>m(n,t)&&n.isSameDay(e,t[0]),B=(n,e,t)=>m(n,t)&&n.isSameDay(e,t[1]);export{P as a,B as b,M as c,x as g,m as i,K as r};
